#include QMK_KEYBOARD_H

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

#define L_ALP 0
#define L_FUN 1
#define L_NUM 2
#define L_UML 3

#define M_ALP 4
#define M_FUN 5
#define M_NUM 6
#define M_UML 7

#define CTL_TAB  LCTL_T(KC_TAB)
#define SFT_BSPC RSFT_T(KC_BSPC)

enum custom_keycodes {
    MAC_MODE = SAFE_RANGE,
    KC_DOT_COMM,
    KC_EXLM_QUES,
    KC_SLSH_BSLS,
    // KC_PREV_WORD,
    // KC_NEXT_WORD,
    // KC_PREV_TAB,
    // KC_NEXT_TAB,
    // KC_BSPC_WORD,
    // KC_DEL_WORD,
    // KC_U_UML,
    // KC_A_UML,
    // KC_O_UML,
    // KC_S_UML,
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    /*
    [L_ALP] = LAYOUT_WHTK(
        KC_DEL,        KC_TILD,       KC_EQL,        KC_PLUS,       KC_MINS,       KC_UNDS,       KC_COMM,       KC_DOT,        KC_EXLM,       KC_QUES,       KC_GRV,        KC_NO,
        KC_ENT,        KC_Q,          KC_W,          KC_E,          KC_R,          KC_T,          KC_Y,          KC_U,          KC_I,          KC_O,          KC_P,          KC_COLN,
        KC_LALT,       KC_A,          KC_S,          KC_D,          KC_F,          KC_G,          KC_H,          KC_J,          KC_K,          KC_L,          KC_DQUO,       KC_SCLN,
        KC_LSFT,       KC_BSLS,       KC_Z,          KC_X,          KC_C,          KC_V,          KC_B,          KC_N,          KC_M,          KC_QUOT,       KC_SLSH,       KC_RCTL,
                                      KC_ESC,        KC_TAB,                                                                    KC_BSPC,       KC_DEL,
                                                                    CTL_TAB,       KC_SPC,        KC_ENT,        SFT_BSPC,
                                                                    KC_LGUI,       MO(L_FUN),     MO(L_NUM),     MO(L_FUN),
                                                                    LSFT(KC_LGUI), MO(L_NUM),     MO(L_UML),     KC_RALT
    ),
    */
    [L_ALP] = LAYOUT_WHTK(
        KC_NO,         KC_NO,         KC_GRV,        KC_EQL,        KC_MINS,       KC_SLSH_BSLS,  KC_QUOT,       KC_DOT_COMM,   KC_EXLM_QUES,  KC_SCLN,       KC_NO,         KC_NO,
        KC_NO,         KC_Q,          KC_W,          KC_E,          KC_R,          KC_T,          KC_Y,          KC_U,          KC_I,          KC_O,          KC_P,          KC_NO,
        KC_NO,         KC_A,          KC_S,          KC_D,          KC_F,          KC_G,          KC_H,          KC_J,          KC_K,          KC_L,          KC_ESC,        KC_NO,
        KC_LALT,       KC_LSFT,       KC_Z,          KC_X,          KC_C,          KC_V,          KC_B,          KC_N,          KC_M,          KC_DEL,        KC_RCTL,       KC_NO,
                                      KC_DEL,        KC_ENT,                                                                    KC_NO,         KC_NO,
                                                                    CTL_TAB,       KC_SPC,        KC_ENT,        SFT_BSPC,
                                                                    KC_LGUI,       MO(L_FUN),     MO(L_NUM),     MO(L_FUN),
                                                                    LSFT(KC_LGUI), MO(L_NUM),     MO(L_UML),     KC_RALT
    ),
    [L_FUN] = LAYOUT_WHTK(
        RESET,         KC_NO,         KC_AT,         KC_LT,         KC_GT,         KC_CIRC,       KC_MS_L,       KC_MS_D,       KC_MS_U,       KC_MS_R,       KC_BTN1,       KC_BTN2,
        KC_NO,         KC_NO,         KC_HASH,       KC_LCBR,       KC_RCBR,       KC_ASTR,       LCTL(KC_LEFT), KC_HOME,       KC_END,        LCTL(KC_RGHT), KC_PSCR,       KC_SLCK,
        KC_NO,         KC_NO,         KC_DLR,        KC_LPRN,       KC_RPRN,       KC_AMPR,       KC_LEFT,       KC_DOWN,       KC_UP,         KC_RGHT,       KC_INS,        KC_PAUS,
        KC_TRNS,       KC_TRNS,       KC_PERC,       KC_LBRC,       KC_RBRC,       KC_PIPE,       LCTL(KC_PGUP), KC_PGDN,       KC_PGUP,       LCTL(KC_PGDN), KC_TRNS,       KC_NO,
                                      KC_NO,         KC_NO,                                                                     KC_NO,         KC_NO,
                                                                    KC_TRNS,       KC_NO,         KC_NO,         KC_BSPC,
                                                                    KC_TRNS,       KC_TRNS,       KC_TRNS,       KC_TRNS,
                                                                    KC_TRNS,       KC_TRNS,       KC_TRNS,       KC_TRNS
    ),
    [L_NUM] = LAYOUT_WHTK(
        KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_COMM,       KC_DOT,        KC_NO,         KC_NO,         KC_NO,         KC_NO,
        KC_NO,         KC_NO,         KC_F1,         KC_F2,         KC_F3,         KC_F4,         KC_0,          KC_1,          KC_2,          KC_3,          KC_NO,         KC_NO,
        KC_NO,         KC_NO,         KC_F5,         KC_F6,         KC_F7,         KC_F8,         KC_NO,         KC_4,          KC_5,          KC_6,          KC_NO,         KC_NO,
        KC_TRNS,       KC_TRNS,       KC_F9,         KC_F10,        KC_F11,        KC_F12,        KC_NO,         KC_7,          KC_8,          KC_9,          KC_TRNS,       KC_NO,
                                      KC_NO,         KC_NO,                                                                     KC_NO,         KC_NO,
                                                                    KC_TRNS,       KC_NO,         KC_NO,         KC_TRNS,
                                                                    KC_TRNS,       KC_TRNS,       KC_TRNS,       KC_TRNS,
                                                                    KC_TRNS,       KC_TRNS,       KC_TRNS,       KC_TRNS
    ),
    [L_UML] = LAYOUT_WHTK(
        KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,
        KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         RALT(KC_Y),    KC_NO,         RALT(KC_P),    KC_NO,         KC_NO,
        KC_NO,         RALT(KC_Q),    RALT(KC_S),    KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,
        KC_TRNS,       KC_TRNS,       KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_NO,         KC_TRNS,       KC_NO,
                                      KC_NO,         KC_NO,                                                                     KC_NO,         KC_NO,
                                                                    KC_NO,         KC_NO,         KC_NO,         KC_RSFT,
                                                                    KC_NO,         KC_NO,         KC_NO,         KC_NO,
                                                                    KC_NO,         KC_NO,         KC_TRNS,       KC_NO
    ),
};

uint8_t mods_state = 0;

bool check_mod_and_clear(uint16_t keycode) {
    bool mod_active = get_mods() & MOD_BIT(keycode);

    if (mod_active) {
        del_mods(MOD_BIT(keycode));
    }

    return mod_active;
}

void mod_set(uint16_t keycode) {
    mods_state |= MOD_BIT(keycode);
}

void mod_clear(uint16_t keycode) {
    mods_state &= ~MOD_BIT(keycode);
}

void mod_restore(uint16_t keycode) {
    if (mods_state & MOD_BIT(keycode)) {
        add_mods(MOD_BIT(KC_LSHIFT));
    } else {
        del_mods(MOD_BIT(KC_LSHIFT));
    }
}

void shift_cleared_alternative(keyrecord_t *record, uint16_t keycode, uint16_t modded_keycode) {
    if (record->event.pressed) {
        if (check_mod_and_clear(KC_LSHIFT) || check_mod_and_clear(KC_RSHIFT)) {
          register_code(modded_keycode);
        } else {
          register_code(keycode);
        }
    } else {
        mod_restore(KC_LSHIFT);
        mod_restore(KC_RSHIFT);
        unregister_code(keycode);
        unregister_code(modded_keycode);
    }
}

void shift_all_alternative(keyrecord_t *record, uint16_t keycode, uint16_t modded_keycode) {
    if (record->event.pressed) {
        if (get_mods() & MOD_BIT(KC_LSHIFT) || get_mods() & MOD_BIT(KC_RSHIFT)) {
          register_code(modded_keycode);
        } else {
          add_mods(MOD_BIT(KC_LSHIFT));
          register_code(keycode);
        }
    } else {
        mod_restore(KC_LSHIFT);
        unregister_code(keycode);
        unregister_code(modded_keycode);
    }
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
    case KC_LSHIFT:
    case KC_RSHIFT:
        if (record->event.pressed) {
            mod_set(keycode);
        } else {
            mod_clear(keycode);
        }
        return true;

    case KC_DOT_COMM:
      shift_cleared_alternative(record, KC_DOT, KC_COMM);
      return false;

    case KC_EXLM_QUES:
      shift_all_alternative(record, KC_EXLM, KC_QUES);
      return false;

    case KC_SLSH_BSLS:
      shift_cleared_alternative(record, KC_SLSH, KC_BSLS);
      return false;

    default:
      mod_restore(KC_LSHIFT);
      mod_restore(KC_RSHIFT);
      return true;
  }
}
